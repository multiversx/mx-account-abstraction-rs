// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct AccountAbstractionProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for AccountAbstractionProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = AccountAbstractionProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        AccountAbstractionProxyMethods { wrapped_tx: tx }
    }
}

pub struct AccountAbstractionProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> AccountAbstractionProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> AccountAbstractionProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> AccountAbstractionProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn register_user<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedByteArray<Env::Api, 64usize>>,
    >(
        self,
        user_address: Arg0,
        signature: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("registerUser")
            .argument(&user_address)
            .argument(&signature)
            .original_result()
    }

    pub fn deposit_for_user<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user_address: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("depositForUser")
            .argument(&user_address)
            .original_result()
    }

    pub fn get_user_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserTokens")
            .argument(&user_address)
            .original_result()
    }

    pub fn get_user_nonce<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserNonce")
            .argument(&user_address)
            .original_result()
    }

    pub fn multi_action_for_user<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, MultiValue3<GeneralActionData<Env::Api>, u64, ManagedByteArray<Env::Api, 64usize>>>>,
    >(
        self,
        user_address: Arg0,
        actions: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("multiActionForUser")
            .argument(&user_address)
            .argument(&actions)
            .original_result()
    }

    /// Pairs of (user_address, actions_vec) 
    pub fn multi_action_for_multi_users<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, ManagedVec<Env::Api, ActionStruct<Env::Api>>>>>,
    >(
        self,
        args: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("multiActionForMultiUsers")
            .argument(&args)
            .original_result()
    }

    /// Pairs of (SC address, endpoint name) 
    pub fn whitelist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, ManagedBuffer<Env::Api>>>>,
    >(
        self,
        whitelist_address: Arg0,
        action_types: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelist")
            .argument(&whitelist_address)
            .argument(&action_types)
            .original_result()
    }

    /// Pairs of (SC address, endpoint name) 
    pub fn remove_whitelist<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, ManagedBuffer<Env::Api>>>>,
    >(
        self,
        whitelist_address: Arg0,
        action_types: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeWhitelist")
            .argument(&whitelist_address)
            .argument(&action_types)
            .original_result()
    }

    /// To pass EGLD payment, simply use "EGLD" as token ID, 0 nonce, and the needed amount 
    pub fn take_action<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg3: ProxyArg<ManagedVec<Env::Api, ManagedBuffer<Env::Api>>>,
        Arg4: ProxyArg<OptionalValue<EsdtTokenPayment<Env::Api>>>,
    >(
        self,
        user_address: Arg0,
        sc_address: Arg1,
        endpoint_name: Arg2,
        endpoint_args: Arg3,
        opt_user_tokens: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("takeAction")
            .argument(&user_address)
            .argument(&sc_address)
            .argument(&endpoint_name)
            .argument(&endpoint_args)
            .argument(&opt_user_tokens)
            .original_result()
    }

    pub fn save_intents<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, MultiValue3<GeneralActionData<Env::Api>, u64, ManagedByteArray<Env::Api, 64usize>>>>,
    >(
        self,
        user_address: Arg0,
        actions: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("saveIntents")
            .argument(&user_address)
            .argument(&actions)
            .original_result()
    }

    /// Pairs of (user_address, actions_vec) 
    pub fn multi_user_save_intents<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, ManagedVec<Env::Api, ActionStruct<Env::Api>>>>>,
    >(
        self,
        args: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("multiUserSaveIntents")
            .argument(&args)
            .original_result()
    }

    pub fn execute_intent<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        user_address: Arg0,
        intent_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("executeIntent")
            .argument(&user_address)
            .argument(&intent_id)
            .original_result()
    }

    pub fn get_all_whitelisted_users<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        whitelist_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllWhitelistedUsers")
            .argument(&whitelist_address)
            .original_result()
    }

    pub fn get_whitelist_types<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        whitelist_address: Arg0,
        users: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedVec<Env::Api, WhitelistAction<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistTypes")
            .argument(&whitelist_address)
            .argument(&users)
            .original_result()
    }

    pub fn get_all_user_intent_ids<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        user_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllUserIntentIds")
            .argument(&user_address)
            .original_result()
    }

    pub fn get_intent_info<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        user_address: Arg0,
        intent_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Intent<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIntentInfo")
            .argument(&user_address)
            .argument(&intent_id)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedDecode, NestedEncode, ManagedVecItem)]
pub struct GeneralActionData<Api>
where
    Api: ManagedTypeApi,
{
    pub call_type: CallType,
    pub dest_address: ManagedAddress<Api>,
    pub payments: ManagedVec<Api, EsdtTokenPayment<Api>>,
    pub opt_execution: Option<ScExecutionData<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedDecode, NestedEncode, ManagedVecItem)]
pub enum CallType {
    Transfer,
    Sync,
    Async,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedDecode, NestedEncode, ManagedVecItem)]
pub struct ScExecutionData<Api>
where
    Api: ManagedTypeApi,
{
    pub endpoint_name: ManagedBuffer<Api>,
    pub args: ManagedVec<Api, ManagedBuffer<Api>>,
    pub gas_limit: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedDecode, NestedEncode, ManagedVecItem)]
pub struct ActionStruct<Api>
where
    Api: ManagedTypeApi,
{
    pub action: GeneralActionData<Api>,
    pub user_nonce: u64,
    pub signature: ManagedByteArray<Api, 64usize>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedDecode, NestedEncode, ManagedVecItem)]
pub struct WhitelistAction<Api>
where
    Api: ManagedTypeApi,
{
    pub sc_address: ManagedAddress<Api>,
    pub endpoint_name: ManagedBuffer<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedDecode, NestedEncode, ManagedVecItem)]
pub struct Intent<Api>
where
    Api: ManagedTypeApi,
{
    pub intent_type: IntentType,
    pub intent_data: GeneralActionData<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedDecode, NestedEncode, ManagedVecItem)]
pub enum IntentType {
    AwaitingExecution,
    InProgress,
}
